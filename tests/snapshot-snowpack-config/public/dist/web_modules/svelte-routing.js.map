{"version":3,"file":"svelte-routing.js","sources":["../../node_modules/svelte/store/index.mjs","../../node_modules/svelte-routing/src/contexts.js","../../node_modules/svelte-routing/src/history.js","../../node_modules/svelte-routing/src/utils.js","../../node_modules/svelte-routing/src/Router.svelte","../../node_modules/svelte-routing/src/Route.svelte","../../node_modules/svelte-routing/src/Link.svelte"],"sourcesContent":["import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","export const LOCATION = {};\nexport const ROUTER = {};\n","/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nfunction getLocation(source) {\n  return {\n    ...source.location,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\"\n  };\n}\n\nfunction createHistory(source, options) {\n  const listeners = [];\n  let location = getLocation(source);\n\n  return {\n    get location() {\n      return location;\n    },\n\n    listen(listener) {\n      listeners.push(listener);\n\n      const popstateListener = () => {\n        location = getLocation(source);\n        listener({ location, action: \"POP\" });\n      };\n\n      source.addEventListener(\"popstate\", popstateListener);\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener);\n\n        const index = listeners.indexOf(listener);\n        listeners.splice(index, 1);\n      };\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      state = { ...state, key: Date.now() + \"\" };\n      // try...catch iOS Safari limits to 100 pushState calls\n      try {\n        if (replace) {\n          source.history.replaceState(state, null, to);\n        } else {\n          source.history.pushState(state, null, to);\n        }\n      } catch (e) {\n        source.location[replace ? \"replace\" : \"assign\"](to);\n      }\n\n      location = getLocation(source);\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }));\n    }\n  };\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nfunction createMemorySource(initialPathname = \"/\") {\n  let index = 0;\n  const stack = [{ pathname: initialPathname, search: \"\" }];\n  const states = [];\n\n  return {\n    get location() {\n      return stack[index];\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack;\n      },\n      get index() {\n        return index;\n      },\n      get state() {\n        return states[index];\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        index++;\n        stack.push({ pathname, search });\n        states.push(state);\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        stack[index] = { pathname, search };\n        states[index] = state;\n      }\n    }\n  };\n}\n\n// Global history uses window.history as the source if available,\n// otherwise a memory history\nconst canUseDOM = Boolean(\n  typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n);\nconst globalHistory = createHistory(canUseDOM ? window : createMemorySource());\nconst { navigate } = globalHistory;\n\nexport { globalHistory, navigate, createHistory, createMemorySource };\n","/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nconst paramRe = /^:(.+)/;\n\nconst SEGMENT_POINTS = 4;\nconst STATIC_POINTS = 3;\nconst DYNAMIC_POINTS = 2;\nconst SPLAT_PENALTY = 1;\nconst ROOT_POINTS = 1;\n\n/**\n * Check if `string` starts with `search`\n * @param {string} string\n * @param {string} search\n * @return {boolean}\n */\nexport function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}\n\n/**\n * Check if `segment` is a root segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isRootSegment(segment) {\n  return segment === \"\";\n}\n\n/**\n * Check if `segment` is a dynamic segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isDynamic(segment) {\n  return paramRe.test(segment);\n}\n\n/**\n * Check if `segment` is a splat\n * @param {string} segment\n * @return {boolean}\n */\nfunction isSplat(segment) {\n  return segment[0] === \"*\";\n}\n\n/**\n * Split up the URI into segments delimited by `/`\n * @param {string} uri\n * @return {string[]}\n */\nfunction segmentize(uri) {\n  return (\n    uri\n      // Strip starting/ending `/`\n      .replace(/(^\\/+|\\/+$)/g, \"\")\n      .split(\"/\")\n  );\n}\n\n/**\n * Strip `str` of potential start and end `/`\n * @param {string} str\n * @return {string}\n */\nfunction stripSlashes(str) {\n  return str.replace(/(^\\/+|\\/+$)/g, \"\");\n}\n\n/**\n * Score a route depending on how its individual segments look\n * @param {object} route\n * @param {number} index\n * @return {object}\n */\nfunction rankRoute(route, index) {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS;\n\n        if (isRootSegment(segment)) {\n          score += ROOT_POINTS;\n        } else if (isDynamic(segment)) {\n          score += DYNAMIC_POINTS;\n        } else if (isSplat(segment)) {\n          score -= SEGMENT_POINTS + SPLAT_PENALTY;\n        } else {\n          score += STATIC_POINTS;\n        }\n\n        return score;\n      }, 0);\n\n  return { route, score, index };\n}\n\n/**\n * Give a score to all routes and sort them on that\n * @param {object[]} routes\n * @return {object[]}\n */\nfunction rankRoutes(routes) {\n  return (\n    routes\n      .map(rankRoute)\n      // If two routes have the exact same score, we go by index instead\n      .sort((a, b) =>\n        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n      )\n  );\n}\n\n/**\n * Ranks and picks the best route to match. Each segment gets the highest\n * amount of points, then the type of segment gets an additional amount of\n * points where\n *\n *  static > dynamic > splat > root\n *\n * This way we don't have to worry about the order of our routes, let the\n * computers do it.\n *\n * A route looks like this\n *\n *  { path, default, value }\n *\n * And a returned match looks like:\n *\n *  { route, params, uri }\n *\n * @param {object[]} routes\n * @param {string} uri\n * @return {?object}\n */\nfunction pick(routes, uri) {\n  let match;\n  let default_;\n\n  const [uriPathname] = uri.split(\"?\");\n  const uriSegments = segmentize(uriPathname);\n  const isRootUri = uriSegments[0] === \"\";\n  const ranked = rankRoutes(routes);\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    const route = ranked[i].route;\n    let missed = false;\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri\n      };\n      continue;\n    }\n\n    const routeSegments = segmentize(route.path);\n    const params = {};\n    const max = Math.max(uriSegments.length, routeSegments.length);\n    let index = 0;\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index];\n      const uriSegment = uriSegments[index];\n\n      if (routeSegment !== undefined && isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/* or /files/*splatname\n        const splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\n\n        params[splatName] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      let dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        const value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}\n\n/**\n * Check if the `path` matches the `uri`.\n * @param {string} path\n * @param {string} uri\n * @return {?object}\n */\nfunction match(route, uri) {\n  return pick([route], uri);\n}\n\n/**\n * Add the query to the pathname if a query is given\n * @param {string} pathname\n * @param {string} [query]\n * @return {string}\n */\nfunction addQuery(pathname, query) {\n  return pathname + (query ? `?${query}` : \"\");\n}\n\n/**\n * Resolve URIs as though every path is a directory, no files. Relative URIs\n * in the browser can feel awkward because not only can you be \"in a directory\",\n * you can be \"at a file\", too. For example:\n *\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\n *  browserSpecResolve('foo', '/bar') => /foo\n *\n * But on the command line of a file system, it's not as complicated. You can't\n * `cd` from a file, only directories. This way, links have to know less about\n * their current path. To go deeper you can do this:\n *\n *  <Link to=\"deeper\"/>\n *  // instead of\n *  <Link to=`{${props.uri}/deeper}`/>\n *\n * Just like `cd`, if you want to go deeper from the command line, you do this:\n *\n *  cd deeper\n *  # not\n *  cd $(pwd)/deeper\n *\n * By treating every path as a directory, linking to relative paths should\n * require less contextual information and (fingers crossed) be more intuitive.\n * @param {string} to\n * @param {string} base\n * @return {string}\n */\nfunction resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\");\n  const [basePathname] = base.split(\"?\");\n  const toSegments = segmentize(toPathname);\n  const baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\");\n\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./       , /users/123 => /users/123\n  // ../      , /users/123 => /users\n  // ../..    , /users/123 => /\n  // ../../one, /a/b/c/d   => /a/b/one\n  // .././one , /a/b/c/d   => /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments);\n  const segments = [];\n\n  allSegments.forEach(segment => {\n    if (segment === \"..\") {\n      segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}\n\n/**\n * Combines the `basepath` and the `path` into one path.\n * @param {string} basepath\n * @param {string} path\n */\nfunction combinePaths(basepath, path) {\n  return `${stripSlashes(\n    path === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`\n  )}/`;\n}\n\n/**\n * Decides whether a given `event` should result in a navigation or not.\n * @param {object} event\n */\nfunction shouldNavigate(event) {\n  return (\n    !event.defaultPrevented &&\n    event.button === 0 &&\n    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n  );\n}\n\nexport { stripSlashes, pick, match, resolve, combinePaths, shouldNavigate };\n","<script>\n  import { getContext, setContext, onMount } from \"svelte\";\n  import { writable, derived } from \"svelte/store\";\n  import { LOCATION, ROUTER } from \"./contexts.js\";\n  import { globalHistory } from \"./history.js\";\n  import { pick, match, stripSlashes, combinePaths } from \"./utils.js\";\n\n  export let basepath = \"/\";\n  export let url = null;\n\n  const locationContext = getContext(LOCATION);\n  const routerContext = getContext(ROUTER);\n\n  const routes = writable([]);\n  const activeRoute = writable(null);\n  let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.\n\n  // If locationContext is not set, this is the topmost Router in the tree.\n  // If the `url` prop is given we force the location to it.\n  const location =\n    locationContext ||\n    writable(url ? { pathname: url } : globalHistory.location);\n\n  // If routerContext is set, the routerBase of the parent Router\n  // will be the base for this Router's descendants.\n  // If routerContext is not set, the path and resolved uri will both\n  // have the value of the basepath prop.\n  const base = routerContext\n    ? routerContext.routerBase\n    : writable({\n        path: basepath,\n        uri: basepath\n      });\n\n  const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {\n    // If there is no activeRoute, the routerBase will be identical to the base.\n    if (activeRoute === null) {\n      return base;\n    }\n\n    const { path: basepath } = base;\n    const { route, uri } = activeRoute;\n    // Remove the potential /* or /*splatname from\n    // the end of the child Routes relative paths.\n    const path = route.default ? basepath : route.path.replace(/\\*.*$/, \"\");\n\n    return { path, uri };\n  });\n\n  function registerRoute(route) {\n    const { path: basepath } = $base;\n    let { path } = route;\n\n    // We store the original path in the _path property so we can reuse\n    // it when the basepath changes. The only thing that matters is that\n    // the route reference is intact, so mutation is fine.\n    route._path = path;\n    route.path = combinePaths(basepath, path);\n\n    if (typeof window === \"undefined\") {\n      // In SSR we should set the activeRoute immediately if it is a match.\n      // If there are more Routes being registered after a match is found,\n      // we just skip them.\n      if (hasActiveRoute) {\n        return;\n      }\n\n      const matchingRoute = match(route, $location.pathname);\n      if (matchingRoute) {\n        activeRoute.set(matchingRoute);\n        hasActiveRoute = true;\n      }\n    } else {\n      routes.update(rs => {\n        rs.push(route);\n        return rs;\n      });\n    }\n  }\n\n  function unregisterRoute(route) {\n    routes.update(rs => {\n      const index = rs.indexOf(route);\n      rs.splice(index, 1);\n      return rs;\n    });\n  }\n\n  // This reactive statement will update all the Routes' path when\n  // the basepath changes.\n  $: {\n    const { path: basepath } = $base;\n    routes.update(rs => {\n      rs.forEach(r => (r.path = combinePaths(basepath, r._path)));\n      return rs;\n    });\n  }\n  // This reactive statement will be run when the Router is created\n  // when there are no Routes and then again the following tick, so it\n  // will not find an active Route in SSR and in the browser it will only\n  // pick an active Route after all Routes have been registered.\n  $: {\n    const bestMatch = pick($routes, $location.pathname);\n    activeRoute.set(bestMatch);\n  }\n\n  if (!locationContext) {\n    // The topmost Router in the tree is responsible for updating\n    // the location store and supplying it through context.\n    onMount(() => {\n      const unlisten = globalHistory.listen(history => {\n        location.set(history.location);\n      });\n\n      return unlisten;\n    });\n\n    setContext(LOCATION, location);\n  }\n\n  setContext(ROUTER, {\n    activeRoute,\n    base,\n    routerBase,\n    registerRoute,\n    unregisterRoute\n  });\n</script>\n\n<slot></slot>\n","<script>\n  import { getContext, onDestroy } from \"svelte\";\n  import { ROUTER, LOCATION } from \"./contexts.js\";\n\n  export let path = \"\";\n  export let component = null;\n\n  const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);\n  const location = getContext(LOCATION);\n\n  const route = {\n    path,\n    // If no path prop is given, this Route will act as the default Route\n    // that is rendered if no other Route in the Router is a match.\n    default: path === \"\"\n  };\n  let routeParams = {};\n  let routeProps = {};\n\n  $: if ($activeRoute && $activeRoute.route === route) {\n    routeParams = $activeRoute.params;\n  }\n\n  $: {\n    const { path, component, ...rest } = $$props;\n    routeProps = rest;\n  }\n\n  registerRoute(route);\n\n  // There is no need to unregister Routes in SSR since it will all be\n  // thrown away anyway.\n  if (typeof window !== \"undefined\") {\n    onDestroy(() => {\n      unregisterRoute(route);\n    });\n  }\n</script>\n\n{#if $activeRoute !== null && $activeRoute.route === route}\n  {#if component !== null}\n    <svelte:component this=\"{component}\" location={$location} {...routeParams} {...routeProps}  />\n  {:else}\n    <slot params=\"{routeParams}\" location={$location}></slot>\n  {/if}\n{/if}\n","<script>\n  import { getContext, createEventDispatcher } from \"svelte\";\n  import { ROUTER, LOCATION } from \"./contexts.js\";\n  import { navigate } from \"./history.js\";\n  import { startsWith, resolve, shouldNavigate } from \"./utils.js\";\n\n  export let to = \"#\";\n  export let replace = false;\n  export let state = {};\n  export let getProps = () => ({});\n\n  const { base } = getContext(ROUTER);\n  const location = getContext(LOCATION);\n  const dispatch = createEventDispatcher();\n\n  let href, isPartiallyCurrent, isCurrent, props;\n  $: href = to === \"/\" ? $base.uri : resolve(to, $base.uri);\n  $: isPartiallyCurrent = startsWith($location.pathname, href);\n  $: isCurrent = href === $location.pathname;\n  $: ariaCurrent = isCurrent ? \"page\" : undefined;\n  $: props = getProps({\n    location: $location,\n    href,\n    isPartiallyCurrent,\n    isCurrent\n  });\n\n  function onClick(event) {\n    dispatch(\"click\", event);\n\n    if (shouldNavigate(event)) {\n      event.preventDefault();\n      // Don't push another entry to the history stack when the user\n      // clicks on a Link to the page they are currently on.\n      const shouldReplace = $location.pathname === href || replace;\n      navigate(href, { state, replace: shouldReplace });\n    }\n  }\n</script>\n\n<a href=\"{href}\" aria-current=\"{ariaCurrent}\" on:click=\"{onClick}\" {...props}>\n  <slot></slot>\n</a>\n"],"names":["subscriber_queue","writable","value","start","noop","stop","subscribers","set","new_value","safe_not_equal","run_queue","length","i","s","push","update","fn","subscribe","run","invalidate","subscriber","index","indexOf","splice","derived","stores","initial_value","single","Array","isArray","stores_array","auto","inited","values","pending","cleanup","sync","result","is_function","unsubscribers","map","store","run_all","LOCATION","ROUTER","getLocation","source","location","state","history","key","globalHistory","options","listeners","[object Object]","listener","popstateListener","action","addEventListener","removeEventListener","to","replace","Date","now","replaceState","pushState","e","forEach","createHistory","Boolean","window","document","createElement","initialPathname","stack","pathname","search","states","name","entries","_","uri","split","createMemorySource","navigate","paramRe","startsWith","string","substr","isSplat","segment","segmentize","stripSlashes","str","rankRoute","route","score","default","path","reduce","isRootSegment","test","isDynamic","SEGMENT_POINTS","pick","routes","match","default_","uriPathname","uriSegments","isRootUri","ranked","sort","a","b","rankRoutes","l","missed","params","routeSegments","max","Math","routeSegment","uriSegment","undefined","slice","decodeURIComponent","join","dynamicMatch","exec","addQuery","query","combinePaths","basepath","url","locationContext","getContext","routerContext","activeRoute","hasActiveRoute","base","routerBase","registerRoute","$base","_path","matchingRoute","$location","rs","unregisterRoute","onMount","listen","setContext","r","bestMatch","$routes","ctx","component","routeParams","routeProps","onDestroy","$activeRoute","rest","$$props","getProps","dispatch","createEventDispatcher","href","isPartiallyCurrent","isCurrent","props","toPathname","toQuery","basePathname","toSegments","baseSegments","concat","allSegments","segments","pop","resolve","ariaCurrent","event","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","shouldNavigate","preventDefault","shouldReplace"],"mappings":"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"}